# 2. 완전 검색 & 그리디

-------------------

- 목차
    - 반복(Iteration)과 재귀(Recursion)
    - 완전검색 기법
    - 순열
    - 부분집합
    - 조합
    - 탐욕 알고리즘
    - 활동 선택 문제
    - Baby-jin

 -------------------

## 반복(Iteration)과 재귀(Recursion)

- 반복과 재귀는 유사한 작업 수행
- 반복은 수행작업 완료될 때 까지 반복
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용

### - 반복

- 반복구조\
  초기화 > 조건검사 > 반복 명령문 실행 > 업데이트

- 반복을 이용한 선택정렬
    ```python
    def SelectionSort(A):
        n = len(A)
        for i in range(0,n-1):
            minI = i
            for j in range(i+1, n):
                if A[j] < A[minI]:
                    minI = j
            A[minI], A[i] = A[i], A[minI]
    ```

### - 재귀

- 재귀적 알고리즘
    - 재귀적 정의는 두 부분으로 나뉨
    - 하나 또는 그 이상의 기본 경우(basis case or rule)
        - 집합에 포함된 워노로 induction을 생성하기 위한 시드역할
    - 하나 또는 그 이상의 유도된 경우(inductive case or rule)
        - 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법


- 재귀함수
    - 함수 내부에서 직접, 간접적으로 자기자신을 호출하는 함수
    - 재귀적 정의 이용 > 기본 부분과 유도 부분으로 구성
    - 함수호출은 프로그램 메모리 구조에서 스택 사용
    - 반복적인 스택의 사용 > 메모리 및 속도에서 성능저하


- 기본형

    ```python           
    def f(i, N):  # i 현재 상태, N 목표
        if i == N:
            print(B)
            return
        else:
            B[i] = A[i]
            f(i + 1, N)
    
    
    N = 5
    A = [1, 2, 3, 4, 5]
    B = [0] * 5
    f(0, N)
    # [1, 2, 3, 4, 5]
    ```

- key 가 있으면 1, 없으면 0을 리턴하는 함수

    ```python
  # i 현재 상태, N 목표, key 찾고자 하는 원소
    def f(i, N, key, arr):  
        if i == N:
            return 0  # key 가 없는 경우
        elif arr[i] == key:
            return 1
        else:
            return f(i + 1, N, key, arr)
    
    
    N = 5
    A = [1, 2, 3, 4, 5]
    key = 10
    print(f(0, N, key, A))
    # key = 3 => 1
    # key = 10 => 0
    ```

- 선택 정렬 재귀적 알고리즘
    ```python
    # 선택정렬 재귀
    # selection_Sort(i):# i 번째 자리에 놓을 리스트에서 i 번째로 작은 원소 찾기
    # 리스트 길이 5라면
    # selection_Sort(0):# 0 번째 자리에 제일 작은 원소 놓기
    # selection_Sort(1):# 0 번째 자리에 그 다음 작은 원소 놓기
    
    def selection_Sort(i, N, arr):
        # 종료조건
        # N-1 번째 까지만 정렬해주면 마지막 자리는 자동으로 정렬됨
        if i == N-1:
            return
    
        # i번 인덱스에서 해야할 일
        else:
            # 제일 작은 값을 가진 인덱스
            # 앞에서 부터 차례대로 채워 나가므로 i로 설정하고
            minI = i
            # 배열의 i 번째 다음 요소들 부터 탐색하여
            for j in range(i + 1, N):
                # 제일 작은값 찾으면
                if arr[j] < arr[minI]:
                    # 제일 작은 값을 가진 인덱스를 갱신해주고
                    minI = j
            # i번 인덱스에 놓기 (자리교환)
            arr[minI], arr[i] = arr[i], arr[minI]
            # 재귀호출 i+1 자리에 놓을 그 다음 작은 원소 찾으러
            selection_Sort(i + 1, N, arr)
    
    
    arr = [3, 2, 6, 4, 8]
    N = len(arr)
    selection_Sort(0, N, arr)
    print(arr) # [2, 3, 4, 6, 8]
    ```
- 재귀함수 항상 호출한 값들을 거슬러 와야한다.

- 반복 또는 재귀?
    
    |비교|재귀|반복|
    |:---:|:---:|:---:|
    |종료|재귀 함수 호출이 종료되는 베이스 케이스(base case)|반복문의 종료 조건|
    |수행시간|(상대적)느림|빠름|
    |메모리 공간|(상대적)많이 사용|적제 사용|
    |소스 코드 길이|짧고 간결|길다|
    |소스 코드 형태|선택 구조(if..else)|반복 구조(for, while)|
    |무한 반복시|스택 오버플로우|CPU를 반복해서 점유|

------------
## 완전검색 기법
### 고지식한 방법(brute-force)
- brute-force 는 문제 해결을 위한 간단하고 쉬운 접근법
- 대부분의 문제에 적용 가능
- 상대적으로 빠른 시간에 문제해결(알고리즘 설계) 가능
- 문제에 포함된 자료(요소, 인스턴스)의 크기가 작다면 유용
- 모든 경우의 수를 생성하고 테스트하여 수행속도 느리지만 해답을 찾아내지 못할 확률이 작다.
    - 완전 검색은 입력의 크기를 작게해 빠르게 답을 구하는 프로그램 작성
- 그리디 기법, 동적 계획법을 이용해 효율적인 알고리즘 찾기 가능
- 우선 완전 검색으로 접근하여 해답 도출 후, 성능 개선을 위한 다른 알고리즘 사용하고 해답 확인하는 것이 바람직

--------

## 순열

- 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열 : `nPr`
- `nPr = n*(n-1)*(n-2)*...*(n-r+1)`
- `nPn = n*(n-1)*(n-2)*...*2*1 = n!`
- 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 거과 관련
    - TSP(Traveling Salesman Problem)
- N 개의 요소들에 대해 n! 개의 순열들이 존재
---
- 단순하게 순열 생성하는 방법
    - {1,2,3} 을 포함하는 모든 순열 생성\
        동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop 이용
        ```python
        S = [1,2,3]
        for i1 in S:
            for i2 in S:
                if i2 != i1:
                    for i3 in S:
                        if i3 != i1 and i3 != i2:
                            print(i1,i2,i3)
        ```
    
- 사전적 순서(Lexicographic-Order)
- 최소 변경을 통한 방법
    - 각각의 순열들은 이전의 상태에서 단지 두 개의 요소들 교환을 통해 생성
    

```python
# 주어진 카드를 모두 뽑아 나열하는 경우
def f(i, N):
    if i == N:  # 순열 완성
        print(p)
        return
    else:  # p[i]에 들어갈 숫자를 결정
        for j in range(N):
            if used[j] == 0:  # 아직 사용되기 전이면
                p[i] = card[j]
                used[j] = 1
                f(i + 1, N)
                used[j] = 0


card = [1, 2, 3, 4, 5, 6]
used = [0] * 6  # 이미 사용한 카드인지 표시
p = [0] * 6
f(0, 6)
```

```python
# 주어진 카드 중 몇개만 뽑아 나열하는 경우
def f(i, N, K):  # i 이전에 고른개수, N개에서 K개를 고르는 순열
    global cnt
    if i == K:  # 순열 완성 : K개를 모두 고른 경우
        cnt += 1
        print(cnt, p)
        return
    else:  # p[i]에 들어갈 숫자를 결정
        for j in range(N):
            if used[j] == 0:  # 아직 사용되기 전이면
                p[j] = card[j]
                used[j] = 1
                f(i + 1, N, K)
                used[j] = 0


card = [1, 2, 3, 4, 5]
N = len(card)  # N개의 숫자에서
K = 3  # K개를 골라 만드는 순열   
cnt = 0  # 순열 개수 기록
used = [0] * N  # 이미 사용한 카드인지 표시
p = [0] * K
f(0, N, K)
```

------
## 부분집합
- 집합에 포함된 원소들을 선택하는 것
- 많은 알고리즘이 그룹에서 최적의 부분집합 찾는 것
  

- 바이너리 카운팅(Binary Counting)
    - 원소 수에 해당하는 N개의 비트열을 이용한다
    - n번째 비트값이 1이면 n번쨰 원소가 포함되었음을 의미한다
    

- 바이너리 카운팅을 이용한 부분집합 생성
    ```python
    a = [1,2,3,4]
    N = 4
    # for i in range(1, (1<<N)-1): # 공집합 안생기게
    # for i in range(1, (1<<N)//2): # 그리고 중복 안생기게
    for i in range(1, 1<<(N-1)): # 위에거랑 같은거
        group1 = []
        group2 = []
        for j in range(N):
            if i&(1<<j):    # j번 비트가 0이 아니면, (i&(1<<j))>>j 0과 1을 딱 만들고 싶으면
                group1.append(a[j])
            else:
                group2.append(a[j])
        print(group1, group2)
        '''
        [1] [2, 3, 4]
        [2] [1, 3, 4]
        [1, 2] [3, 4]
        [3] [1, 2, 4]
        [1, 3] [2, 4]
        [2, 3] [1, 4]
        [1, 2, 3] [4]
        '''
        r1 = f(group1)
        r2 = f(group1)
    ```
## 조합

- 서로다른 n개의 원소 중 r개를 순서 없이 골라낸 것 : 조합(Combination)
- 조합의 수식
    - `nCr = n!/(n-r)!r!`
    - `nCr = n-1Cr-1 + n-1Cr`
    - `nC0 =1`
    
- 재귀 호출을 이용한 조합 생성 알고리즘
```python
    def ncr(n,r):
        if r == 0:
            print(tr)
        elif n<r:   # 남은 원소보다 많은 원소를 선택해야 하는경우
            return
        else:
            tr[r-1] = a[n-1] # a[n-1]을 조합에 포함시키는 경우
            ncr(n-1,r-1)
            ncr(n-1,r)  # a[n-1]을 조합에 포함시키는 않는 경우

    N = 5
    R = 3
    a = [1,2,3,4,5]
    tr = [0] * R
    ncr(N,R)
```
- 10개의 원소 중 3개를 고르는 조합
```python
a = [1,2,3,4,5,6,7,8,9,10]
# i<j<k
for i in range(10-3+1):
    for j in range(i+1, 10-2+1):
        for k in range(j+1, 10-1+1):
            print(a[i], a[j], a[k])
    
```  
- n개에서 r개를 고르는 조합
```python
# n개에서 r개를 고르는 조합, s 선택할 수 있는 구간의 시작
def nCr(n,r,s):
    if r == 0:
        print(*comb)
    else:
        for i in range(s,n-r+1):
            comb[r-1] = A[i]
            nCr(n,r-1,i+1)

A = [1,2,3,4,5]
N = len(A)
R = 3
comb = [0] * R
nCr(N, R, 0)
```
- 연습문제 : 부분집합의 합
```python
def subset(i, N, s):

    if s == 0:
        return 1
    elif i == N:
        return 0
    else:
        if subset(i + 1, s + arr[i]):
            return 1
        if subset(i + 1, N, s):
            return 1
        return 0

arr = [-1, 3, -9, 6, 7, -6, 1, 5, 4, -2]
N = len(arr)
bit = [0] * N
subset(0, N, 0)
```

---------
## 탐욕 알고리즘
- 최적해를 구하는데 사용되는 근시안적인 방법
- 일반적으로, 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy


- 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식
- 각 선택 시점에서는 최적이지만, 그것이 전체에 있어서 최적이라는 보장은 없다
- 일단, 한번 선택된 것은 번복하지 않아서 대부분 탐욕 알고리즘은 단순하며, 제한적인 문제들에 적용한다.
- 최적화 문제란 가능한 해들 중에서 가장 좋은 해를 찾는 문제


- 탐욕 알고리즘의 동작 과정
    1. 해선택 : 현재 상태에서 부분 문제의 최적해를 구한뒤, 이를 부분집합에 추가  
    2. 실행 가능성 검사 : 새로운 부분 해 집합이 실행 가능한지 확인, 문제 제약조건 위반 검사
    3. 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지 확인, 만약 해 아니면 1의 해 선택부터 다시 시작
    

### 활동 선택 문제

- 탐욕 기법을 적용한 알고리즘
```python

```
---
### 탐욕 알고리즘의 필수 요소
- 탐욕적 선택 속성(greedy choice property)
    - 탐욕적 선택은 최적해로 갈 수 있음을 보여라 -> 즉, 탐욕적 선택은 항상 안전하다.
  
- 최적 부분구조(optimal substructure property)
        - 최적화 문제를 정형화하라 -> 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다
  
- [원문제의 최적해 = 탐욕적 선택 + 하위문제의 최적해] 임을 증명하라

- 탐욕기법과 동적 계획법의 비교 
  
  |탐욕기법|동적 계획법|
  |:---:|:---:|
  |매 단에서, 가장 보이는 것을 빠르게 선택.-> 지역 최적선택|매 단계의 선택은 해결한 하위 문제의 해를 기반으로 한다.|
  |하위 문제를 풀기 전에 (탐욕적) 선택이 먼저 이루어짐|하위 문제가 우선 해결|
  |Top-down 방식|Bottom-up 방식|
  |일반적으로, 빠르고 간결|좀더 느리고, 복잡|

