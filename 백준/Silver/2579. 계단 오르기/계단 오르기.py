'''
계단 오르기

- 계단 아래서 꼭대기 까지
- 계단 :
    - 각 계단마다 점수 존재
- 올라가기
    - 한 번에 한 계단씩 or 두 계단씩
    - 연속된 세 개의 계단을 모두 밟으면 안됨
    - 시작점은 계단에 포함 X
    - 도착 계단은 반드시 밟아야 한다.

- 각 층까지의 최대 점수를 저장
- 현재층까지 오는 경우는 2칸 전이나 1칸전
- 각 칸에서의 경우는
- dp[i-3]+s[i-1]+s[i] : i-3 계단까지 최댓값과 i-1, i 계단의 합
- dp[i-2]+s[i] : i-2 계단까지 계단 최댓값과 i 계단의 합
- 근데 마지막 계단은 무조건 밟아야 하니까 거꾸로하면 더 좋나?
- 어짜피 각 층에서 최대값 저장되니까 상관없다
'''

# 계단의 개수
N = int(input())
score = [0]+[int(input()) for _ in range(N)]
# print(score)
dp = [0]*(N+1)
# 시작점은 첫번째 계단으로 한칸으로든 두칸으로든 계단 오른 횟수에 영향 안줌
# 끝점은 무조건 밟아야 하니까 거꾸로 돌자
if len(score)<=3: # 계단이 2개 이하
    print(sum(score))
else: # 계단이 3개 이상일v 때
    dp[N]=score[N] # 마지막 계단 초기설정
    dp[N-1]=score[N]+score[N-1] # 마지막 두번쨰 계단 계산
    dp[N-2] = score[N] + score[N-2]
    for i in range(N-3,-1,-1): # 3번째 계단 부터 dp 점화식 이용해서 최대값 구하기
        dp[i]=max(dp[i+3]+score[i+1]+score[i], dp[i+2]+score[i])
        # print(dp)
    print(max(dp[0],dp[1]))