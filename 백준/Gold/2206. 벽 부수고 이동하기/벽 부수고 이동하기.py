'''
벽부수고 이동하기

- N x M 의 행렬 맵
- 0 : 이동할 수 있는 곳, 1 : 이동할 수 없는 벽

- 상황 : (1,1)에서 (N,M)의 위치까지 최단경로로 이동
- 만약 한 개의 벽을 부수고 이동하는 것 가능
- 이동할 수 있는칸 상하좌우
- 불가능하면 -1

1. 먼저 출발점으로 부터 탐색을 하자
    - 0인부분만 탐색을 하면서 가고 각 위치까지의 최단 거리를 기록
    - 벽인 부분은 벽까지의 최단거리만 구해놓고 바로 탐색하진 말자 = x
        - 벽인부분도 기록해주고 탐색 큐에 넣어준다 대신 
        - 누적기록은 배열의 다른공간에 기록한다 
        - 해당 벽을 뚫었을 때 최단경로라면 통로보다 큐의 탐색 순위에서 우선이기 때문에
        - 최단경로를 구할 수 있다.
    - 근데 벽마다 공간을 그 수만큼 더 만들어 줘야 하는가?
        - 처음에 공간을 하나씩 다 deepcopy 하여 만들어 줬는데
        - N*M*(배열크기) 만큼 복잡도가 반복되서 안된다
    - 생각해보면 벽마다 다 뚫을 때를 고려해주며 탐색해줘도 결국에 최단경로인 얘가
    먼저 도착지점에 도착할 것이다
    - 왜냐하면 bfs 특성상 같은 거리에 있는 곳들을 다 큐에 넣어놓고 거리 1만큼씩 차례로 전진하기 떄문이다
    - 대신 벽인 부분을 담아줄 때는 내가 있는 지금 위치가 통로여야한다.
    - 벽 > 벽 은 뚫어도 소용없는 구간이기 때문에
---아래는 필요 없음
2. 뚫을 벽들을 담은 리스트들을 순회하며
    - 각 벽을 뚫었을 때 도착점 까지 도달한다면 최단경로를 계속 갱신
    - 도달 못하면 건너뛰고
    - 다 탐색해도 못가면 -1 출력

- BFS 이용
- 다익스트라??

'''
from collections import deque


def bfs(x,y,z):

    # 방문 체크
    visited[x][y][z] = 1
    # 탐색큐 생성
    q = deque()
    q.append((x,y,z))
    # 다 탐색할 때 까지
    while q:
        #현재위치
        x,y,z = q.popleft()
        # 만약에 종료지점 찾으면
        if (x,y) == (N-1,M-1):
            return visited[x][y][z]
        # 상하좌우 4방향 탐색
        for dx,dy in [[1,0],[-1,0],[0,1],[0,-1]]:
            nx,ny = x + dx, y + dy
            if 0<= nx < N and 0<= ny < M:
                # 탐색하는 곳이 벽이고 내가 지금 있는 곳은 통로라면
                if maze[nx][ny] == 1 and z == 0:
                    # 벽 위치에 현재위치에서 거리 1만큼 추가한거 기록하고
                    visited[nx][ny][1] = visited[x][y][z] + 1
                    # 큐에다가 추가해라
                    q.append((nx, ny, 1))
                # 탐색하는 곳이 통로고, 아직 방문하지 않았다면
                elif maze[nx][ny] == 0 and visited[nx][ny][z] == 0:
                    # 벽과 통로의 방문기록에 둘 다 누적거리 입력하고
                    visited[nx][ny][z] = visited[x][y][z] + 1
                    # 큐에 추가해줘라
                    q.append((nx, ny, z))
                    
    # 중간에 도착하지 못하면
    # -1
    return -1

N, M = map(int, input().split())
maze = [list(map(int,input())) for _ in range(N)]
# 방문체크
# 3차원 행렬을 통해 벽의 파괴를 파악함. visited[x][y][0]은 벽 파괴 가능. [x][y][1]은 불가능.
visited = [[[0] * 2 for _ in range(M)] for _ in range(N)]
print(bfs(0,0,0))


