''''''
'''
# SW 문제 해결 역량
# 복잡도 분석
## 알고리즘
    - 알고리즘 : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
    
    - 알고리즘의 효율
        - 공간적 효율성과 시간적 효율성
            - 공간적 효율성 : 연산량 대비 얼마나 적은 메모리 공간을 요하는가
            - 시간적 효율성 : 연산량 대비 얼마나 적은 시간을 요하는 가
            - 효율성을 뒤집어 표현하면 복잡도(Complexity) => 복잡도 높으면 효율성 저하

        - 시간적 복잡도 분석
            - 하드웨어 환경에 따라 처리시간 달라짐 : 장비 성능
            - 소프트웨어 환경에 따라 처리시간 달라짐 : 언어, 운영체제, 컴파일러 종류
    
    - 복접도의 점근적 표기
        - 시간 또는 공간 복잡도는 입력 크기에 대한 함수로 표기함
        - 이를 단순한 함수로 표현하기 위해 점근적 표기(Asymptotic Notation) 사용
        
            - 빅 오 - 점근적 상한 - 실행시간이 n^2 에 비례하고 이거보다는 덜 걸릴 거야 최악은 이거만큼 걸려
           
            - 빅오메가 - 점근적 하한 - 최소한 이만한 시간은 걸린다
            
            - 빅 세타 표기 = 빅오와 빅오메가가 같은 경우 - n이 증가함에 따라 n^2과 동일한 증가율

## 표준입출력
- 입력
    -Raw 값의 입력 : input()
        - 받은 입력값 문자열 취급
    -Evaluated된 값 입력 : eval(input())
        받은 입력값 평가된 데이터 형으로 취급
    
- 출력
    -print()
        -표준 출력함수.출력값의 마지막에 개행문자 포함
    -print('text', end = '')
        - 출력시 마지막에 개행문자 제외시
    -print('%d' %number)
        - Fommatting 된 출력

- 파일의 내용을 표준 입력으로 읽어오는 방법
    ```
    import sys
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output', 'w')
    ```
    
- 2차원 리스트 입력 받을 때 둘러싼 지역을 추가 하고 싶으면
    `arr = [[0]*(N+2)] + [[0] + list(map(int, input().split())) + [0] for _ in range(N)] + [[0]*(N+2)] `
    위의 식으로 해결 가능
    
    
## 비트 연산
    
'''
# 비트연산 예제 1
# 비트연산 예제 2
def Bbit_print(i):
    output = ''



'''
 엔디안(Endianness)
    - 개념
        - 컴퓨터의 메모리와 같은 1차원의 공간에 여러개의 연속된 대상을 배열하는 방법
        - 주의 : 속도 향상을 위해 바이트 단어와, 워드 단어 변환하여 연산시 올바르게 이해하지
        않으면 오류 발생시킬수도 있다.
        - 빠른 자리에 낮은 자리부터 할지 높은 자리부터 할지 
        
    - 종류
        - 빅 엔디안
            - 보통 큰 단위가 앞에 다옴. 네트워크  0x1234 12 34    
        - 리틀 엔디안   
            - 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터 0x1234 34 12    
     
'''
# 비트 연산 예제 3
def ce(n): # change endian
    p = []
    for i in range(0,4):
        p.append()

# 비트연산 예제 4
# 비트연산 예제 5

'''
## 진수
    - 2진수, 8진수, 10진수, 16진수
    
    - 10진수 => 타 진수로 변환
        - 원하는 타진법의 수로 나누고 나머지를 거꾸로 읽는다
    
    - 타 진수 => 10진수로 변환
        - (135)8 = 1*8^2 + 3*8^1 + 5*8^0
        - 소수점이 있을 때의 예
        - (21.12)8 = 2*8^1 + 1*8^0 + 1*8^-1 + 2*8^-2
        
    - 2진수, 8진수, 16진수간 변환
        - 2, 8 => 3자리씩 묶거나 나열
        - 2, 6 => 4자리씩 묶거나 나열
'''
# 2진수 만들기
bit = [0]*8
a = 149
i = 7
while a>= 2:
    bit[i] = a%2
    a //= 2
    i -= 1
bit[i] = a
print(''.join(map(str,bit)))
'''
    - 컴퓨터에서의 음의 정수 표현 방법
        - 1의 보수 - 부호 비트 제외한 나머지 비트 0>1, 1>0 으로 변환
            - 0, -0 이 존재하게 되어 안씀
        - 2의 보수 - 1의 보수 방법으로 표현된 값의 최하위 비트에 1을 더한다.
        
## 실수
    
'''