# 2. 완전 검색 & 그리디

-------------------

- 목차
    - 반복(Iteration)과 재귀(Recursion)
    - 완전검색 기법
    - 순열
    - 부분집합
    - 조합
    - 탐욕 알고리즘
    - 활동 선택 문제
    - Baby-jin

 -------------------

## 반복(Iteration)과 재귀(Recursion)

- 반복과 재귀는 유사한 작업 수행
- 반복은 수행작업 완료될 때 까지 반복
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용

### - 반복

- 반복구조\
  초기화 > 조건검사 > 반복 명령문 실행 > 업데이트

- 반복을 이용한 선택정렬
    ```python
    def SelectionSort(A):
        n = len(A)
        for i in range(0,n-1):
            minI = i
            for j in range(i+1, n):
                if A[j] < A[minI]:
                    minI = j
            A[minI], A[i] = A[i], A[minI]
    ```

### - 재귀

- 재귀적 알고리즘
    - 재귀적 정의는 두 부분으로 나뉨
    - 하나 또는 그 이상의 기본 경우(basis case or rule)
        - 집합에 포함된 워노로 induction을 생성하기 위한 시드역할
    - 하나 또는 그 이상의 유도된 경우(inductive case or rule)
        - 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법


- 재귀함수
    - 함수 내부에서 직접, 간접적으로 자기자신을 호출하는 함수
    - 재귀적 정의 이용 > 기본 부분과 유도 부분으로 구성
    - 함수호출은 프로그램 메모리 구조에서 스택 사용
    - 반복적인 스택의 사용 > 메모리 및 속도에서 성능저하


- 기본형

    ```python           
    def f(i, N):  # i 현재 상태, N 목표
        if i == N:
            print(B)
            return
        else:
            B[i] = A[i]
            f(i + 1, N)
    
    
    N = 5
    A = [1, 2, 3, 4, 5]
    B = [0] * 5
    f(0, N)
    # [1, 2, 3, 4, 5]
    ```

- key 가 있으면 1, 없으면 0을 리턴하는 함수

    ```python
  # i 현재 상태, N 목표, key 찾고자 하는 원소
    def f(i, N, key, arr):  
        if i == N:
            return 0  # key 가 없는 경우
        elif arr[i] == key:
            return 1
        else:
            return f(i + 1, N, key, arr)
    
    
    N = 5
    A = [1, 2, 3, 4, 5]
    key = 10
    print(f(0, N, key, A))
    # key = 3 => 1
    # key = 10 => 0
    ```

- 선택 정렬 재귀적 알고리즘
    ```python
    # 선택정렬 재귀
    # selection_Sort(i):# i 번째 자리에 놓을 리스트에서 i 번째로 작은 원소 찾기
    # 리스트 길이 5라면
    # selection_Sort(0):# 0 번째 자리에 제일 작은 원소 놓기
    # selection_Sort(1):# 0 번째 자리에 그 다음 작은 원소 놓기
    
    def selection_Sort(i, N, arr):
        # 종료조건
        # N-1 번째 까지만 정렬해주면 마지막 자리는 자동으로 정렬됨
        if i == N-1:
            return
    
        # i번 인덱스에서 해야할 일
        else:
            # 제일 작은 값을 가진 인덱스
            # 앞에서 부터 차례대로 채워 나가므로 i로 설정하고
            minI = i
            # 배열의 i 번째 다음 요소들 부터 탐색하여
            for j in range(i + 1, N):
                # 제일 작은값 찾으면
                if arr[j] < arr[minI]:
                    # 제일 작은 값을 가진 인덱스를 갱신해주고
                    minI = j
            # i번 인덱스에 놓기 (자리교환)
            arr[minI], arr[i] = arr[i], arr[minI]
            # 재귀호출 i+1 자리에 놓을 그 다음 작은 원소 찾으러
            selection_Sort(i + 1, N, arr)
    
    
    arr = [3, 2, 6, 4, 8]
    N = len(arr)
    selection_Sort(0, N, arr)
    print(arr) # [2, 3, 4, 6, 8]
    ```
- 재귀함수 항상 호출한 값들을 거슬러 와야한다.

- 반복 또는 재귀?
    
    |비교|재귀|반복|
    |:---:|:---:|:---:|
    |종료|재귀 함수 호출이 종료되는 베이스 케이스(base case)|반복문의 종료 조건|
    |수행시간|(상대적)느림|빠름|
    |메모리 공간|(상대적)많이 사용|적제 사용|
    |소스 코드 길이|짧고 간결|길다|
    |소스 코드 형태|선택 구조(if..else)|반복 구조(for, while)|
    |무한 반복시|스택 오버플로우|CPU를 반복해서 점유|

------------
## 완전검색 기법
### 고지식한 방법(brute-force)
- brute-force 는 문제 해결을 위한 간단하고 쉬운 접근법
- 대부분의 문제에 적용 가능
- 상대적으로 빠른 시간에 문제해결(알고리즘 설계) 가능
- 문제에 포함된 자료(요소, 인스턴스)의 크기가 작다면 유용
- 모든 경우의 수를 생성하고 테스트하여 수행속도 느리지만 해답을 찾아내지 못할 확률이 작다.
    - 완전 검색은 입력의 크기를 작게해 빠르게 답을 구하는 프로그램 작성
- 그리디 기법, 동적 계획법을 이용해 효율적인 알고리즘 찾기 가능
- 우선 완전 검색으로 접근하여 해답 도출 후, 성능 개선을 위한 다른 알고리즘 사용하고 해답 확인하는 것이 바람직

--------

## 순열

- 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열 : `nPr`
- `nPr = n*(n-1)*(n-2)*...*(n-r+1)`
- `nPn = n*(n-1)*(n-2)*...*2*1 = n!`
- 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 거과 관련
    - TSP(Traveling Salesman Problem)
- N 개의 요소들에 대해 n! 개의 순열들이 존재
---
- 단순하게 순열 생성하는 방법
    - {1,2,3} 을 포함하는 모든 순열 생성\
        동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop 이용
        ```python
        S = [1,2,3]
        for i1 in S:
            for i2 in S:
                if i2 != i1:
                    for i3 in S:
                        if i3 != i1 and i3 != i2:
                            print(i1,i2,i3)
        ```
    
- 사전적 순서(Lexicographic-Order)
- 최소 변경을 통한 방법
    - 각각의 순열들은 이전의 상태에서 단지 두 개의 요소들 교환을 통해 생성
    

```python
# 주어진 카드를 모두 뽑아 나열하는 경우
def f(i, N):
    if i == N:  # 순열 완성
        print(p)
        return
    else:  # p[i]에 들어갈 숫자를 결정
        for j in range(N):
            if used[j] == 0:  # 아직 사용되기 전이면
                p[i] = card[j]
                used[j] = 1
                f(i + 1, N)
                used[j] = 0


card = [1, 2, 3, 4, 5, 6]
used = [0] * 6  # 이미 사용한 카드인지 표시
p = [0] * 6
f(0, 6)
```

```python
# 주어진 카드 중 몇개만 뽑아 나열하는 경우
def f(i, N, K):  # i 이전에 고른개수, N개에서 K개를 고르는 순열
    global cnt
    if i == K:  # 순열 완성 : K개를 모두 고른 경우
        cnt += 1
        print(cnt, p)
        return
    else:  # p[i]에 들어갈 숫자를 결정
        for j in range(N):
            if used[j] == 0:  # 아직 사용되기 전이면
                p[j] = card[j]
                used[j] = 1
                f(i + 1, N, K)
                used[j] = 0


card = [1, 2, 3, 4, 5]
N = len(card)  # N개의 숫자에서
K = 3  # K개를 골라 만드는 순열   
cnt = 0  # 순열 개수 기록
used = [0] * N  # 이미 사용한 카드인지 표시
p = [0] * K
f(0, N, K)
```

------
## 부분집합


```python
a = [1,2,3,4]
N = 4
# for i in range(1, (1<<N)-1): # 공집합 안생기게
# for i in range(1, (1<<N)//2): # 그리고 중복 안생기게
for i in range(1, 1<<(N-1)): # 위에거랑 같은거
    group1 = []
    group2 = []
    for j in range(N):
        if i&(1<<j):    # j번 비트가 0이 아니면, (i&(1<<j))>>j 0과 1을 딱 만들고 싶으면
            group1.append(a[j])
        else:
            group2.append(a[j])
    print(group1, group2)
    '''
    [1] [2, 3, 4]
    [2] [1, 3, 4]
    [1, 2] [3, 4]
    [3] [1, 2, 4]
    [1, 3] [2, 4]
    [2, 3] [1, 4]
    [1, 2, 3] [4]
    '''
    r1 = f(group1)
    r2 = f(group1)
```